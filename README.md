# 贺菜狗机考准备

> **开始时间:** 2023/03/11
>
> **准备目标:** 在各大高校的机试中尽量少丢分，不被其他竞争者拉开差距
>
> **目前成果：** **厦门大学**计科系夏令营机试**450**分(满分470分)，机试排名前20。

## 知识点积累

#### 数理基础

##### 最大公约数和最小公倍数

一般来说，是**通过求两个数的最大公约数**来求最小公倍数。

至于最大公约数的求法，一般是用**辗转相除法**。其步骤如下：

> 即对于a和b，选其中**较大**的数做**被除数x**，**较小**的做**除数y**，二者除法的**余数**为c。
>
> - **c = x%y**；
> - 若c!=0，则x=y; y=c。转第一步。
> - 若c==0，则y就是最大公约数。

当我们求得两个数的最大公约数后，即可利用最大公约数求出最小公倍数。

> **基本理念**： **a * b  =  最小公倍数*最大公约数**



#### C语言

##### 输入多组数据

有的题目要求能够输入多组数据，而不是每次输入只有一组数据。为了应对这种要求，需要使用下面的代码来完成。

```c
while(scanf("%d",&n)!=EOF){
	// 操作
}
```



#### 链表

动态链表往往适用于面试答题，但对于机试就不适用了，因为分配空间十分耗时。所以为了能够稳定应对机试，应通过静态链表的方式来实现链表，即使用**数组**模拟。

##### 单链表

单链表的结构，即每个节点存放**值**和**指向下一节点的指针**。如果要用数组来模拟，则需要两个数组。

###### 部分操作代码

```c
// val[i] 存放第i个插入的节点，ne[i] 存放第i个插入节点的下一个节点的插入位序(在数组中的位置)
int val[N],ne[N];
// head指向队首，idx指向下一个可插入的数组单元(和队列的tt同理)
int head,idx;

void init(){
    // 链表为空
    head = -1;
    idx = 0;
}

// 在链表头部插入一个节点
void insert_to_head(int x){
    val[idx] = x;
    ne[idx] = head;
    head = idx;
    idx++;
}

// 在第k个插入的节点后面插入一个节点
void insert_after_k(int x,int k){
    // 第k个插入的数在数组的下标是k-1
    // 取得它的下一个节点位序
    int nex = ne[k-1];
    val[idx] = x;
    ne[idx] = nex;
    ne[k-1] = idx;
    idx++;
}

// 删除第k个插入的数后面的数
void delete_after_k(int k){
    // k==0 删除头节点
    if(k==0){
        head = ne[head];
        return ;
    }
    int nex = ne[k-1];
    ne[k-1] = ne[nex];
}
```

理解了数组怎么模拟链表后，按照链表各种操作的特性就可以很轻易的写出操作的函数，机试尽可能还是用这种办法来做。

##### 双链表

双链表即每个节点新增一个指向上一节点的指针，那么用数组模拟的话就新开一个数组，用来存放上一节点指针。

###### 部分操作代码

```c
// 舍弃前两个单元用作首尾指针，且二者相连，即r[0] = 1,l[1] = 0;
int l[N],r[N],val[N];
int idx;
void init(){
    l[1] = 0;
    r[0] = 1;
    idx = 2;// 前两个空间占用了，故从2开始
}

// 在第k个插入的数右侧加入一个新值x
// 若让在第k个插入的数左侧新增值x，则就是在k的左侧的值的右侧新增值，即调用add(l[k],x)即可
void add(int k,int x){
    // 得出真实下标 +2是因为第一个数放在 下标为2的单元内
    k = k-1+2;
    int ne = r[k];
    val[idx] = x;
    r[idx] = ne;
    l[idx] = k;
    r[k] = idx;
    idx++;
}

void remove(int k){
    // 获取正确下标
    k = k-1+2;
    r[l[k]] = r[k];
    l[r[k]] = l[k];
}
```



#### 并查集

##### 并查集解决的问题

并查集是通过**树**的数据结构来存储集合的，即每一个集合对应一个树，而每个集合内的第一个数的编号就充当这棵树的根节点。并查集的查询和合并操作的时间复杂度均 **近似O(1)**。

###### 常见的并查集用法

> - 查询两个元素是否属于同一集合
>
> - 合并两个集合
>
>   (其实所谓**集合**，在**图**中也可以理解为一个**连通子图**)
>
> - **查询**一个图中的**连通子图个数**
>
> - **查询**一个连通子图中的**节点个数**



##### 并查集图解

![image](https://github.com/kirito618/Computer_Test/assets/80687988/1d6589c2-e307-4056-b0a9-ab989473d35e)




##### 并查集的基本代码写法

###### 存储结构

我们使用一个**p数组**来存，p[x] 表示元素x在集合树中的**父节点编号**。

那么，如果 **p[x] = x** ，则**x就是这个集合树的根节点**。

###### 初始化

```c++
// 即初始状态是让每个元素自己是一个集合
for(int i=1;i<=N;i++) p[i] = i;
```

###### find函数

```c++
// 并查集查找某个元素所属集合的编号 
int find(int x){
    // 这里的思想是路径压缩
    // 在对每个元素完成一次查找后 我们已经找到这个元素所属集合树的根节点了
    // 直接就将这个元素连接在根节点下
    // 那么下一次查找的复杂度就是 o(1) 同时当前节点的子节点查找时间也将减少
	if(p[x]!=x) p[x] = find(p[x]);
	return p[x];
}
```

###### 合并操作

```c++
cin>>a>>b;
if(find(a)!=find(b)){
	// a和b不是一个子图里的,子图数-1 
	subG--;
	// 由于a和b的边已经被考虑了,所以把a和b所属的集合合并
    // 由于上面已经执行了find(a) 那么这里执行find(a)就是o(1),不用担心时间复杂度的问题
	p[find(a)] = find(b);
}
```

关于上面的合并，其实谁合并进谁的集合树，并不重要，**只要能够合并**即可。上面的例子就是**将a所在的集合合并进了b所在的集合**下。



###### 新的认识

上面说到，并查集是能够进行合并和查找的。通过这几天的做题，我对合并的过程有了新的理解。

我们先看下下面这步**合并**的代码写法：

```c++
if(find(a)!=find(b)){
	p[find(a)] = find(b);
}
```

上例中，a和b所属集合不一样，所以我们将a所属的集合合并到b所属的集合下。

也就是说，从a向上走，走到a所属集合的根节点时，将这个根节点直接连在b所属集合的根节点下面。但是find函数是递归的过程，采用了路径压缩的想法，那么这句话执行以后，a所属集合下的所有元素**通过find函数**找到的根都将**等于**find(b)。

那么，如果我们要解决的问题可以被视作寻找子图的问题的话，通过若干次上面的合并，我们就已经把整个图划分成了多个子图。每个子图内所有元素通过find函数找到的根都是一样的，即**find函数返回值是一样的。**

那么，我们可以记录find函数有多少个不同的返回值，那么每个返回值都将代表一个子图，那么**子图数**就出来了；同时，我们还可以记录每种返回值出现的次数，这样我们又知道了**每个子图的元素个数**；如果我们再把find返回值相同的元素记录在一个容器里，我们也就知道了**每个子图内有哪些元素**了...以此类推，会发现并查集能够很好的解决这些复杂的划分问题，PAT上面也有很多类似的题目。

那么，解决**划分子图**问题的**思路**大致如下：

> - 根据题意，构建图(有向图或者无向图都可以，自己根据图结构调整代码)
> - 将所有节点都视为一个单独的集合，即p[i] = i，设置子图数为N
> - 对于所有存在边的两个点，判断是否已经已经合并，如果没合并就合并
> - 合并后将子图数-1，即**N--**
> - 全部执行完后，我们就得到了N个子图，每个子图内的所有元素的find返回值均相同。
> - 根据题意利用划分好的子图来做出解答



##### 查询某个集合的元素个数

上面大部分是在合并，或者是根据合并结果统计各个子图的元素数，但如果我指定要**查询某元素所在集合的元素数**，又该怎么办呢？

这两天做题得到了新思路，维护一个**元素个数数组** **size**，**size[find(i)]** 表示 i 所在集合的元素个数，即**只有每个集合根节点所对应的size值才是有效的**。

**维护方法**：在合并时动态维护

```c
if(find(a)!=find(b)){
	size[find(b)] += size[find(a)];
	p[find(a)] = find(b);
}
```



#### 树

##### 根据中、后序遍历创建树

**对应题目：PAT甲级真题1020**（当然，这题还要求输出此树的层序遍历结果。）

###### 思想：

> 通过**递归**来构建树，每一个递归区间都是一棵**子树**。
>
> 那么在这棵子树中，后序遍历中的最后一个元素就是这棵**子树**的根节点。
>
> 接下来我们需要找到这个根节点在中序遍历中的位置，它的左侧元素就是它的左子树，它的右侧元素就是它的右子树，再进入左右子树完成**递归建树**。



###### 代码实现

```c++
int N;
int inorder[40];
int postorder[40];
// 存储后序遍历中元素在中序遍历里对应的下标 
unordered_map<int,int> post_in_mid;
// 存储每个节点的左右子树的根节点 
unordered_map<int,int> l_son,r_son;

// 递归建树,返回值为根节点 
int build(int il,int ir,int pl,int pr){
	// 每个根节点都是这个子树区间的后序遍历的最后一个值 
	int root = postorder[pr];
	// 取得根节点在中序遍历中的下标 
	int k = post_in_mid[root];
	if(il<k){
		// 说明存在左子树
		// pl+(k-1-il) 是 因为无论是中序还是后序，子树节点个数是一样的
		// 那么区间长度也是一样的，是推导出来的 
		l_son[root] = build(il,k-1,pl,pl+(k-1-il));
	}
	if(k<ir){
		// 存在右子树
		r_son[root] = build(k+1,ir,pl+(k-1-il)+1,pr-1); 
	}
	return root; 
}

```

这种类型的问题比较常见，在leetcode上也见到过类似的题，不过那题是用先、中序遍历来建树，再通过层序遍历输出树的每个节点。不过换汤不换药，都是一样的道理。

只不过，每个子树的根节点是先序遍历对应区间内的第一个值(因为 “根左右”)，然后同样找到根节点在中序遍历里对应的位置，左侧即为左子树，右侧即为右子树。



##### 树的层序遍历

###### 思想：

> **层序遍历**，对应的思想是**bfs**，即**宽度优先搜索**。我们需要维护一个**队列**，这个队列内存储层序遍历得到的节点排序。
>
> 我们利用两个指针来处理这个队列：**hh** 和 **tt**。
>
> 其中，**hh** 指向的是**当前要处理的根节点**，**tt** 指向的是队列中**下一个要填入的位置**。
>
> 在每一轮循环中，我们先通过**hh**指针取得当前需要处理的根节点，然后判断其**是否有左右子树**，如果有，那么我们取出左右子树的根节点，按**先左后右**的顺序将节点存入队列。
>
> 那么，当所有节点都进入队列后，**tt将不再变化**，当hh增加到比tt还大的时候，说明**没有需要处理的节点了**，此时循环结束，并且队列中的顺序就是层序遍历的顺序。



###### 代码实现：

```c++
// 存储后序遍历中元素在中序遍历里对应的下标 
unordered_map<int,int> post_in_mid;
// 存储每个节点的左右子树的根节点 
unordered_map<int,int> l_son,r_son;

// 层序遍历队列 
int q[40];

void bfs(int root){
	// 两个指针 
	int hh=0,tt=0;
	int t;
	q[0] = root;
	while(hh<=tt){
		// 拿到当前队首的根节点 取完后队首指针后移 
		t = q[hh++];
		// 如果左子树map里有key值为当前根节点
		// 说明该节点有左子树 
		if(l_son.count(t)) q[++tt] = l_son[t];
		if(r_son.count(t)) q[++tt] = r_son[t];
	}
	
	cout<<q[0];
	for(int i=1;i<N;i++) cout<<" "<<q[i];
	cout<<endl;
} 
```



###### 组合题

**Acwing1620,PAT1127**:

"Z"型遍历，即奇数行从右向左层序遍历，偶数行从左到右做层序遍历。

这道题首先考察根据某两种遍历方式创建树，然后再考察层序遍历。题目很有意思，在3月份的PAT中也有一个遍历树的题，但当时时间不够，题目还没看就结束了。

整体思路就是先根据第一个知识点把树建出来，建的过程中要记录每一层节点的个数，树的结构我是用l,r数组模拟的。然后建好了就进行层序遍历，记录层序遍历的结果。

然后，针对层序遍历的结果，按照"Z"型遍历的规则来输出。我是按照层进行遍历，先判断这个层是奇数还是偶数，然后确定这一层的所有元素在层序遍历中的下标范围，然后从前往后或者从后往前输出即可。



##### 栈

栈是一个**先进后出**的数据结构，也是数据结构中考察的重点。栈的实现可以采用**一维数组模拟**，也可以**调用STL库**中的stack进行直接使用，我的建议是去用**数组模拟**，会加深对栈的理解。

以下是一个栈的一维数组模拟方式：

```c++
int top=0,bottom=0;
int st[10000];//一维数组模拟栈
void push(int num){
    st[top++] = num;
}

bool pop(int &t){
    if(top==bottom){
        return false;
    }
    t = st[--top];// 传回栈顶值
    return true;
}
```

就目前来看，栈的考察在PAT中一般是要模拟栈的行为，或者是用栈去模拟其他的行为，主要就是**模拟**吧。

2023年6月的PAT甲级考试的第二题便是一道栈模拟题，题目大致是说用两个栈可以模拟出一个队列，题目不难，主要是要懂栈的数据结构特点，如何入栈出栈。当然，如果直接调STL，那就一点问题也没有了，按着题目说的过程去模拟就行了。

###### 题目记录

**Acwing 1543题，PAT甲级1057题**

此题目要求模拟栈的行为，即他给出一种操作，我们模拟这个操作的执行过程。总体上不难，难点在他定义了一种新的操作，这个操作要求输出此时栈里所有元素从小到大排列的序列中，（假设栈内有N个元素）输出第N/2或(N+1)/2个数。

这里的思路就是用STL库中的**multiset**，这个set是在普通set的基础上，允许了元素重复，由于set自身能够自动排序，所以就很契合于这道题。

###### 有关mutiset及set的操作

```c++
// 遍历set，找到第num个数
for(multiset<int>::iterator x=db.begin();x!=db.end();x++,j++){
	if(j==num){
		 cout<<*x<<endl;
		 break;
	}
}

// 删除栈中某个值==num的单元
db.erase(db.find(num));
```



###### 单调栈

**适用问题**：给定一个序列，让你找出某个数左侧最近的某个特定值。如找出第k个数左边最近的最小值。

**思想**

> 由于栈是**“先进后出”**，那么如果按序把每个数入栈，则**栈顶一定是最近的值**。但如果要寻找最小值，直接这么做则只能从栈顶向下找，时间开销较大，和暴力做法没有差别。
>
> **考虑序列：3 4 2 7 5**
>
> 当输入2时，前面有3和4，当2入栈后，3和4就永远不可能被使用了。因为2不仅比3和4小，同时在位置上也离后面的数更近，因此可以考虑直接将这些用不到的节点出栈。当3和4出栈后，则可以将2入栈。
>
> 即输入每个值时，**将栈内大于等于当前值的出栈**。若最后栈空了，则当前值左侧没有比它小的；否则栈顶就是离他最近的较小值。然后再将当前值入栈。
>
> 如此动态维护下去，栈内将会呈现单调递增的趋势，因此称为**单调栈**。



#### 图

##### 图的存储

邻接矩阵就不说了，时间空间开销都较大，只是易于理解，做题一般不采用。

###### 邻接表

**邻接表**，思想与树的**孩子表示法**一致。即每个节点拥有一个单链表，这个单链表里存放的就是图中与当前节点相连的所有节点。

其实在C++中用vector进行嵌套，也是邻接表的思想，但无奈于机考不能使用c++，故要掌握数组模拟方法。

**代码实现**

```c
// 其实跟单链表的实现大致相同，只是邻接表有N个头，即每个节点都会在总链表中占据一段区域
int val[N],ne[N],he[N],idx;

// 头插法,将a与b之间连起一条边,这里是有向边
void add(int a,int b){
    val[idx] = b;
    ne[idx] = he[a];
    he[a] = idx++;
}
```

上面的实现方式十分巧妙，每个节点都拥有自己的链表，但这个链表只是公共链表的某个区域，因此存储空间不是O(N^2)而只是O(N)。

**一般使用前要将所有节点的头指针置为-1** ，表示链表为**空**。

```c
// 用memset为he内的所有空间赋值为-1
memset(he,-1,sizeof he);
```



##### 图的最短路算法

###### **DFS（深度优先搜索）**

> - 适用范围比较宽泛，对于很多操作步骤比较奇怪的问题都可以考虑用DFS，没有固定的模板
> - **数据结构**：**栈**（递归函数栈）
> - **包含思想**：**回溯、剪枝**，这俩是用于优化递归过程，减少不必要计算的方法
> - **缺点：**可以搜到解，但解不一定是最优解，如下面的走迷宫问题，如果非要用DFS求最优解，则需要考虑所有情况，取出全局最优，时间开销大
> - **优点**：相比于BFS，空间要求小

很多经典的问题都是DFS思想，如树的前中后序遍历或建树，以及23年6月的PAT甲级的机器人走迷宫问题，都可以用DFS来做。

**例题**

> **全排列问题**
>
> 即对于正整数n，按增序输出1~n的全排列。
>
> **思路**：通过DFS，在**每一层递归确定一位数字**，确定的方法就是遍历所有**未使用**的数字，然后将其设置为当前位数字，并标记已访问，进入下一位数字的递归；回到当前层时将该数字设为未放问，即**回溯**的思想。

**代码**

```c
#include<stdio.h>
int n;
int result[7],visited[8];

// t为当前确定第几位
void dfs(int t){
    if(t==n+1){
        // 说明n位数字已确定
        for(int i=1;i<=n;i++){
            printf("%d ",result[i]);
        }
        printf("\n");
        return ;
    }
    for(int i=1;i<=n;i++){
        if(visited[i]!=1){
            result[t] = i;
            visited[i] = 1;
            dfs(t+1);
            visited[i] = 0;
        }
    }
}

int main(){
    scanf("%d",&n);
    dfs(1);
    return 0;
}
```



###### BFS（宽度优先搜素）

> - **适用情况：当所有边的权重相同，求单源最短路时适用。**
> - **关键词**：**“最短路”、“最短距离”、“最少步骤”**...等，若每一步所需的距离相同，则BFS一般是适用的。
> - **数据结构：队列**
> - **缺点**：相比于DFS，空间要求比较高
> - **优点**：当**图内所有边的长度均为1**时，那么第一次遍历到某个点时，一定是一条从起点到当前点的**最短路**，因为BFS是逐层扩展的，距离逐渐加1。

代码的写法同树层序遍历的写法，**执行思路**如下：

> 1. 起点入队，标记为已访问
> 2. 将队首元素的所有**未访问**的相邻节点入队，并标记为已访问；
> 3. 队首元素出队，若**队列为空**则结束执行，否则返回步骤2



**例题**

> **走迷宫问题**
>
> **原题链接**：https://www.acwing.com/problem/content/846/
>
> **题目概述**：起点是(1,1)，迷宫大小为n*m，求从起点出发走到终点(n,m)的最短路径(步数)，每个节点之间距离相同。
>
> **思路：**以BFS的思想，每次将队首元素周围可行的点入队，直到队首元素是终点时结束。用结构体维护每个节点的累计步数，那么**终点的累计步数就一定是最短路的长度**。



**代码**

```c++
#include<iostream>
using namespace std;
struct Node{
	int x,y,st;
};

int n,m;
int graph[110][110];
int way[4] = {-1,1,-1,1};
int visited[110][110];
int step;
Node allNodes[10010];
int hh = 0,tt = 0;
void bfs(){
	int x1,y1,x2,y2,ts;
	Node one;
	one.x = 1;
	one.y = 1;
	one.st = 0;
	allNodes[tt++] = one;
	visited[1][1] = 1;
	while(hh<tt){
		x1 = allNodes[hh].x;
		y1 = allNodes[hh].y;
		ts = allNodes[hh].st;
		if(x1==n&&y1==m) break; 
		for(int i=0;i<4;i++){
			if(i<2){
				x2 = x1+way[i];	
				y2 = y1;
			}else{
				y2 = y1+way[i];
				x2 = x1;
			}
			if(x1<=0||y2<=0||x2>n||y2>m) continue;
			if(visited[x2][y2]!=1&&graph[x2][y2]!=1){
				Node temp;
				temp.x = x2;
				temp.y = y2;
				temp.st = ts+1;
				allNodes[tt++] = temp;
				visited[x2][y2] = 1;
			}
		}
		hh++; // 出队 
	}
}

int main(){
	scanf("%d %d",&n,&m);
	for(int i=1;i<=n;i++)
		for(int j=1;j<=m;j++)
			scanf("%d",&graph[i][j]);
	bfs();
	printf("%d\n",allNodes[hh].st);
	return 0;
}
```



###### 朴素Dijkstra算法

**思路**

- dis[i]: 从起点到i号点的最短路径长度。(dis[起点]=0，其他的等于正无穷)
- ok[i]: 表示i号节点是否已经找到最短路。
- 采用**邻接矩阵**存储**稠密图**，采用**邻接表**存储**稀疏图**。

> 1. dis[起点]=0，dis[其他]=正无穷；
> 2. 共进行**n轮**循环，每轮能够确定一个点的最短路；
> 3. 找到当前**未处理**的点中，**dis值最小**的点，记为 t 。
> 4. 将t标记为已找到最短路，同时**考虑t作为中转节点**，以此**更新**所有点的dis值。公式为：**dis[j] = min(dis[j],dis[t]+w[t] [j])；**
> 5. 转至**2**，直至n轮结束

**代码**

```c
int dijkstra(){
    int i,j,t,x;
    memset(dis,0x3f,sizeof dis);
    dis[1] = 0;
    for(i=1;i<=n;i++){
        t = -1;
        // 找到当前没处理的节点中距离最短的
        for(j=1;j<=n;j++){
            if(ok[j]!=1&&(t==-1||dis[t]>dis[j])){
                t = j;
            }
        }
        ok[t] = 1;
        for(j=1;j<=n;j++){
            x = w[t][j]+dis[t];
            dis[j] = x<dis[j]?x:dis[j];
        }
    }
    if(dis[n]==0x3f3f3f3f) return -1;
    return dis[n];
}
```



###### 拓扑序列

拓扑排序适用于**有向无环图**，带有宽度优先搜索的基本思想，按照如下规则生成遍历序列:

> 1. 将所有**入度为0**的节点全部入队；
> 2. 当队列非空时，获得队首元素，并将队首元素出队；
> 3. 将队首元素向外伸出的所有边删除(让延申到的点的入度-1即可)；
> 4. 若入度减1后，小于0了，则将该点也加入队列；
> 5. 回到2步；

等到遍历完成，队列中存放的便是拓扑序列。



##### 最小生成树

###### 朴素Prim算法

**思路**

**dis[i]**: **节点i**到以确定节点**集合**的最短距离。

> 1. 初始化所有**dis数组**值为MAX；
> 2. 找到当前**未确定**最小dis值的点，用它来更新所有其他点到**集合**的距离(注：集合也就是所有已经确定最小dis的点)；
> 3. 把该节点设置为**已确定**，即加入到集合中去；
> 4. 回到2，共进行**n轮**循环；

**代码**

```c
#include<stdio.h>
int n,m;
int w[510][510],st[510];
int dis[510];
// 朴素Prim算法
void prim(){
    int res=0;
    int i,j,t;
    // 全都初始化为0x3f3f3f3f，这是一个很大的值，用来标记未更新
    memset(dis,0x3f,sizeof dis);
    for(i=0;i<n;i++){
        t = -1;
        for(j=1;j<=n;j++){
            // 找到未确定的最小dis值点，这个点离集合最近
            if(st[j]!=1&&(t==-1||dis[t]>dis[j])){
                t = j;
            }
        }
		//如果已经经过一轮处理，还有点的dis[t]为初始值，说明不连通，不可能存在生成树
        if(i!=0 && dis[t]==0x3f3f3f3f){
            printf("impossible\n");
            return ;
        }
		//如果已经更新过一轮，则集合里已经有了一个确定的点，那么可以开始累计记录权重和了
        if(i!=0) res += dis[t];
        // 用t更新所有其他的点，规则就是看看t加入集合以后能不能缩短各点到集合的最短距离
        for(j=1;j<=n;j++) dis[j] = dis[j]<w[t][j]?dis[j]:w[t][j];
        st[t] = 1;
    }
    printf("%d\n",res);
}
```



#### 堆

##### 基本理解

**堆**是一种特别的数据结构，它在形状上满足**完全二叉树**的定义。即它的存储是可以按照完全二叉树那样，存在一个数组里的。

> **完全二叉树存储**
>
> 节点i(下标为i) 的左儿子下标是**2i**，右儿子下标是**2i+1**；
>
> 同理，节点i的父节点则是**i/2**(向下取整)；



##### 堆的种类

> - **大根堆**：每个节点都要**大于等于**它的左右子树的所有值。
> - **小根堆**：每个节点都要**小于等于**它的左右子树的所有值。

那么很明显，如果我们将一个序列构建成大根堆(小根堆)，那么这个堆的顶点就一定是序列的最大值(最小值)。



##### 堆的操作

**y总笔记**

![image](https://github.com/kirito618/Computer_Test/assets/80687988/25a6d112-5e96-423a-9fa1-c079a4eaa1be)


注：其实**down**操作和**up**操作都只会进行其中一个，因为**二者条件互斥**。



##### 堆排序

利用堆的特点，如果能**动态维护**一个堆结构，那么每次取出**堆顶元素**加入序列，最终得到的序列就一定是有序的。



##### 堆排序实现

###### 下沉(down)操作

所谓**down**操作，就是指当堆的结构**不满足定义**时，如大顶堆的根节点比它左右儿子小，此时这个节点应该**下沉到一个正确的位置**从而保证堆结构成立。

**down操作用来调整堆结构，使其满足堆结构定义**

> **思路**
>
> 拿小顶堆来说，当当前节点无法满足堆定义时，需要进行**down**操作。
>
> 1. 取出当前点与其左右儿子节点中值**最小**的点。
> 2. 如果说这个最小值点不是当前的根节点，说明根节点位置有问题，则将根节点与这个最小值点互换位置。
> 3. 接下来对当前根节点进行**递归**处理。(因为交换以后可能被交换的点的位置也不合理)

**代码**

```c
void down(int u){
	int k = u;
	// 若有左儿子,且左儿子不合理
	if(2*u<=n&&heap[2*u]<heap[k]) k = 2*u;
	// 若有右儿子,且右儿子不合理
	if(2*u+1<=n&&heap[2*u+1]<heap[k]) k = 2*u+1;
	if(k!=u){
		reap[0] = reap[k];
		reap[k] = reap[u];
		reap[u] = reap[0];
		down(k);
	}
}
```



###### 上浮up操作	

即将一个节点向上浮动，当当前节点不满足定义时，如小顶堆中当前节点比父节点还小，那当前节点的位置应该和父节点进行调换，也就是所谓的**“上浮”**。

**up操作一般用于向堆中插入元素**

```c
void up(int x){
	while(x/2>=1&&heap[x]<heap[x/2]){
		// 交换父子节点
		heap[0] = heap[x];
		heap[x] = heap[x/2];
		heap[x/2] = heap[0];
		x /= 2;
	}
}
```



###### 删除操作

**删除最小值点**

```c
heap[1] = heap[N--];
down(1);
```



###### 例题

**Acwing 838.堆排序**

注：堆排序只需要down操作即可完成。

> **题目链接**：https://www.acwing.com/problem/content/description/840/

**代码**

```c
#include<stdio.h>
int n,m;
int heap[100010];
int cnt;
// 下降函数
void down(int cur){
    // 先把当前点记录为最小值点
    int t = cur;
    // 有左孩子且左孩子比最小值点小
    if(cur*2<=cnt&&heap[cur*2]<heap[t]){
        t = 2*cur;
    }
    // 有右孩子且右孩子比最小值点小
    if((cur*2+1)<=cnt&&heap[cur*2+1]<heap[t]){
        t = 2*cur+1;
    }
    // 最小的那个点不是根节点，说明根节点有问题，需要换位置
    if(t!=cur){
        heap[0] = heap[t];
        heap[t] = heap[cur];
        heap[cur] = heap[0];
        // 递归使该节点下沉
        down(t);
    }
}

int main(){
    int i;
    scanf("%d %d",&n,&m);
    for(i=1;i<=n;i++) scanf("%d",&heap[i]);
    cnt = n;
    // 建立初始堆,从n/2开始是因为,n/2是这棵树最后一个非叶子节点
    for(i=n/2;i>=1;i--) down(i);
    while(m--){
        // 头节点为当前区域最小值
        printf("%d ",heap[1]);
        // 删除头节点，做法就是把当前区域最后一个值拿过来直接覆盖掉根节点
        heap[1] = heap[cnt--];
        // 重新down操作，保证堆结构合理
        down(1);
    }
    printf("\n");
    return 0;
}

```



**注意**

今天在重刷代码时提交Wrong了，我发现我自己没有注意一个细节，在排序的过程中，我们的思路是每次输出堆顶元素，再将其删掉，从而得到递增序列。但我今天的做法是错误的，**记住，一定要真的把这个值删掉，也就是要把堆节点个数n真的减少**。我今天的错误就出现在我用一个临时变量存了堆的元素个数，结果一直在减少这个临时变量，实际上就没有真的把元素删掉。





#### 散列(哈希)表

使用哈希表来存放数据，也就是所谓的**散列存储**。意思是根据插入的关键字的值，通过某种映射方式得到这个值应该插入的位置。查找时也一样，通过同样的规则计算出查找关键字存放的位置，再按照一定规则从对应位置处开始查找。

比较常用的映射方式是**使用关键字对存储空间大小进行取模操作**，为了保证获得的下标为正，在c/c++中可以通过下面的方式来实现。

```c
// key为插入或查找的关键字，n是哈希表存储空间大小
c = (key%n+n)%n;
```

往往关键字的范围会远远大于散列表的空间大小，所以难免会出现**冲突**(即两个不同的关键字经过映射函数，得到的存放地址相同)，也就出现了一些处理冲突的方法。



##### 拉链法

拉链法，顾名思义，当出现冲突时，所有冲突的元素都会被存放在一个链表里。类似于邻接表，先确定下标位置，数组中每一个位置都对应着一条链表，所有冲突元素都会被挂在对应数组位置下的链表里。

###### 相关代码实现

```c
int MAX = 100010;
int h[100010],val[100010],ne[100010],idx=0;

// 拉链法处理哈希冲突,头插法
void insert_link(int x){
    // 直接取余得到存放位置
    int i = (x%MAX+MAX)%MAX;
    val[idx] = x;
    ne[idx] = h[i];
    h[i] = idx++;
}

// 拉链法查找是否存在元素
int find_link(int x){
    // 直接取余得到存放位置
    int i = (x%MAX+MAX)%MAX;
    // 取得拉链头节点
    for(i = h[i];i!=-1;i=ne[i]){
        if(val[i]==x){
            return 1;
        }
    }
    return 0;
}
```



###### 开放寻址法

基本思想就是，当通过映射得到的位置并不是空闲的时候，就继续向临近的位置探索，直到找到一个可以放的位置。

**代码实现**

```c
// 一般会选择开两倍的空间
int MAX = 0x3f3f3f3f,N = 200020;
int h[200020];
// 开放定址法,如果x存在则返回其存放的位置，否则返回其应该放的位置
int find(int x){
    // 获得映射地址
    int i=(x%N+N)%N;
    // 当这个地址对应的空间不是空闲的，并且也不是要查找的数的时候，就继续向后找
    while(h[i]!=MAX&&h[i]!=x){
        i++;
        // 找到末尾了，此时应该循环从头开始再找
        if(i==N) i=0;
    }
    return i;
}
```

> **注**：**MAX**值是一个**标志值**，这里的作用是用来标注空间是**空闲**的。因为有些题目会规定每个元素的大小，这个**MAX**值一般是比所有规定值都大的，可以用来做标志位。

