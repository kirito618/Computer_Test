## 贺菜狗的PAT刷题之旅

<u>开始于**2022/11/26**</u>

**目前进度为一天一题(若题太简单就多刷一个)，立志在下学期期初的PAT甲级考试中拿到满分！**

![秃头柯南](https://user-images.githubusercontent.com/80687988/205430357-9a139fdd-7800-48ad-beb7-4f3560e39442.jpg)

### 知识点积累

#### 树

##### 根据中、后序遍历创建树

**对应题目：PAT甲级真题1020**（当然，这题还要求输出此树的层序遍历结果。）

###### 思想：

> 通过**递归**来构建树，每一个递归区间都是一棵**子树**。
>
> 那么在这棵子树中，后序遍历中的最后一个元素就是这棵**子树**的根节点。
>
> 接下来我们需要找到这个根节点在中序遍历中的位置，它的左侧元素就是它的左子树，它的右侧元素就是它的右子树，再进入左右子树完成**递归建树**。

###### 代码实现

```c++
int N;
int inorder[40];
int postorder[40];
// 存储后序遍历中元素在中序遍历里对应的下标 
unordered_map<int,int> post_in_mid;
// 存储每个节点的左右子树的根节点 
unordered_map<int,int> l_son,r_son;

// 递归建树,返回值为根节点 
int build(int il,int ir,int pl,int pr){
	// 每个根节点都是这个子树区间的后序遍历的最后一个值 
	int root = postorder[pr];
	// 取得根节点在中序遍历中的下标 
	int k = post_in_mid[root];
	if(il<k){
		// 说明存在左子树
		// pl+(k-1-il) 是 因为无论是中序还是后序，子树节点个数是一样的
		// 那么区间长度也是一样的，是推导出来的 
		l_son[root] = build(il,k-1,pl,pl+(k-1-il));
	}
	if(k<ir){
		// 存在右子树
		r_son[root] = build(k+1,ir,pl+(k-1-il)+1,pr-1); 
	}
	return root; 
}

```

这种类型的问题比较常见，在leetcode上也见到过类似的题，不过那题是用先、中序遍历来建树，再通过层序遍历输出树的每个节点。不过换汤不换药，都是一样的道理。

只不过，每个子树的根节点是先序遍历对应区间内的第一个值(因为 “根左右”)，然后同样找到根节点在中序遍历里对应的位置，左侧即为左子树，右侧即为右子树。



##### 树的层序遍历

###### 思想：

> **层序遍历**，对应的思想是**bfs**，即**宽度优先搜索**。我们需要维护一个**队列**，这个队列内存储层序遍历得到的节点排序。
>
> 我们利用两个指针来处理这个队列：**hh** 和 **tt**。
>
> 其中，**hh** 指向的是**当前要处理的根节点**，**tt** 指向的是队列中**下一个要填入的位置**。
>
> 在每一轮循环中，我们先通过**hh**指针取得当前需要处理的根节点，然后判断其**是否有左右子树**，如果有，那么我们取出左右子树的根节点，按**先左后右**的顺序将节点存入队列。
>
> 那么，当所有节点都进入队列后，**tt将不再变化**，当hh增加到比tt还大的时候，说明**没有需要处理的节点了**，此时循环结束，并且队列中的顺序就是层序遍历的顺序。



###### 代码实现：

```c++
// 存储后序遍历中元素在中序遍历里对应的下标 
unordered_map<int,int> post_in_mid;
// 存储每个节点的左右子树的根节点 
unordered_map<int,int> l_son,r_son;

// 层序遍历队列 
int q[40];

void bfs(int root){
	// 两个指针 
	int hh=0,tt=0;
	int t;
	q[0] = root;
	while(hh<=tt){
		// 拿到当前队首的根节点 取完后队首指针后移 
		t = q[hh++];
		// 如果左子树map里有key值为当前根节点
		// 说明该节点有左子树 
		if(l_son.count(t)) q[++tt] = l_son[t];
		if(r_son.count(t)) q[++tt] = r_son[t];
	}
	
	cout<<q[0];
	for(int i=1;i<N;i++) cout<<" "<<q[i];
	cout<<endl;
} 
```

